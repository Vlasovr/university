//+-----------------------------------------+
//| Автор: Relrin (c) 2011                  |
//|	Библиотека для работы с динамической    |
//| структурой "Двусвязный cписок"          | 
//|                                         |
//| ПРИМЕЧАНИЕ: При необходимости заменить  |
//| char на нужный тип данных               |
//+-----------------------------------------+
#include <stdio.h>
#include <stdlib.h>

struct Node 
{ 
   char word[40];     // область данных 
   int  count; 
   Node *next, *prev; // ссылки на соседние узлы 
}; 
typedef Node *PNode;  // тип данных «указатель на узел» 
/* 
	Для доступа к списку используется не одна переменная-указатель, а
	две – ссылка на «голову» списка (Head) и на «хвост» - 
	послед-ний элемент (Tail).
*/
PNode Head = NULL, Tail = NULL; 

//+--------------------------------------+
//| Добавление элемента в начало списка  |
//| PNode &Head - ук. на начало списка   |
//| PNode &Tail - ук. на конец списка    |
//| NewNode - новый узел                 |
//+--------------------------------------+
void AddFirst(PNode &Head, PNode &Tail, PNode NewNode) 
{ 
   //в новом эл-е, cледующая ссылка ссылается на первый эл-т
   NewNode->next = Head; 
    //а на предыдущий никуда
   NewNode->prev = NULL; 
   //если элемент первый взять, то у него необходимо
   //изменить ссылку на предыдущий элемент(а новый у нас - вставляемый)
   if ( Head ) Head->prev = NewNode; 
   Head = NewNode; 
   if ( ! Tail ) Tail = Head; // этот элемент – первый 
} 

//+--------------------------------------+
//| Добавление элемента в конец списка   |
//| PNode &Head - ук. на начало списка   |
//| PNode &Tail - ук. на конец списка    |
//| NewNode - новый узел                 |
//+--------------------------------------+
void AddLast(PNode &Head, PNode &Tail, PNode NewNode) 
{ 
   //в новом эл-е, предыдущая ссылка ссылается на последний эл-т
   NewNode->prev = Tail; 
   //а на следущий никуда
   NewNode->next = NULL; 
   //если элемент последний взять, то у него необходимо
   //изменить ссылку на следующий элемент(а новый у нас - вставляемый)
   if (Tail) Tail->next = NewNode; 
   //закрепляем новую ссылку как конец
   Tail = NewNode; 
   if (!Head) Head = Tail; // этот элемент – последний
} 

//+--------------------------------------+
//| Добавление элемента в список         |
//| PNode &Head - ук. на начало списка   |
//| PNode &Tail - ук. на конец списка    |
//| PNode p     - после какого вставить  |
//| NewNode - новый узел                 |
//+--------------------------------------+
void AddAfter (PNode &Head, PNode &Tail, PNode p, PNode NewNode) 
{ 
	if (!p->next) 
      AddLast(Head, Tail, NewNode);  // вставка в конец списка
	else
	{ 
		NewNode->next = p->next;  // меняем ссылки нового узла
		NewNode->prev = p; 
		p->next->prev = NewNode;  // меняем ссылки соседних узлов
		p->next = NewNode;     
    } 
} 

//+--------------------------------------+
//| Удаление узла из списка              |
//| PNode &Head - ук. на начало списка   |
//| PNode &Tail - ук. на конец списка    |
//| PNode OldNode - что удаляем          |
//+--------------------------------------+
void Delete(PNode &Head, PNode &Tail, PNode OldNode) 
{ 
   if (Head == OldNode) 
   {  
	   Head = OldNode->next;    // удаляем первый элемент 
	   if( Head ) Head->prev = NULL; 
       else Tail = NULL;        // удалили единственный элемент 
   } 
   else 
   { 
       OldNode->prev->next = OldNode->next; 
       if ( OldNode->next ) OldNode->next->prev = OldNode->prev; 
       else Tail = NULL;       // удалили последний элемент  
   } 
   delete OldNode; 
} 

