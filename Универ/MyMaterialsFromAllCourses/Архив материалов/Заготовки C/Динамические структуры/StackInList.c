//+-----------------------------------------+
//| Автор: Relrin (c) 2011                  |
//|	Библиотека для работы с динамической    |
//| структурой "Стек (LIFO)" для С++        | 
//|                                         |
//| ПРИМЕЧАНИЕ: При необходимости заменить  |
//| char на нужный тип данных               |
//+-----------------------------------------+
#include <stdio.h>

struct Node
{
	char data;         //значение ячейки
	node *next, *prev; //текущее и последнее значение ячейки
}

typedef node *PNode;   //указатель на стек

struct Stack
{
	PNode Head, Tail;  //указатели на начало и конец стека
}

void Push(Stack &s,char x); //Добавление элемента в стек 
char Pop (Stack &s,char x); //Получение значения из вершины стека

//+--------------------------------------+
//| Добавление элемента в стек           |
//| stack &s - адрес на структуру        |
//| char x   - заносимый элемент         |
//+--------------------------------------+
void Push(Stack &s,char x)
{
	//выделяем память
	PNode NewNode;
	NewNode = new Node;
	//записываем в новую ячейку значение
	NewNode->data=x;
	//указываем s.Head на новый элемент, как на вершину стека
	NewNode->next=s.Head;
	//делаем указатель на предыдущий недоступным(если это 1 элемент)
	NewNode->prev=NULL;
	//если это не первый элемент, то в указатель запишем ссылку на предыдущий
	if(s.Head)
	  s.Head->prev=NewNode;
	s.Head=NewNode;
	//если элемент не был определен, где начало стека
	//то запишем в нее значение "дна" стека
	if(!s.Tail) s.Tail=s.Head;
}

//+--------------------------------------+
//| Получение значения из вершины стека  |
//| stack &s - адрес на структуру        |
//| char x   - возвращаемый элемент      |
//+--------------------------------------+
char Pop(Stack &s)
{
	PNode TopNode = s.Head;
	char x;
	
	if(!TopNode)        //если стек пуст
      return char(255); //то вернуть символ с кодом 255

	x=TopNode->data;
	s.Head=TopNode->next;
	if(s.Head) s.Head->prev=NULL; //переставляем ссылки
	else       s.Tail=NULL;

	delete TopNode; //освобождаем память
	return x;
}