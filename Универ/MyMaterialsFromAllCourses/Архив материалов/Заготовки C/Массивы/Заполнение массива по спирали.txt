y        - текуща€ сторона (0 - вверх, 1 - право, 2 - ...)
sizeX    - размер массива по горизонтали
CorrectX - переменна€, котора€ отвечает за автоматическое декриментирование
Count    - переменна€, котора€ отвечает за текущую цыфру внутри массива
Summ     - произведение ширины на высоту, нужно дл€ устранени€ ошибки (см. ƒалее)
Mas      - название двумерного массива
x        - собственно позици€ внутри массива

Ќу, а остальные стороны делаютс€ по вышеописанному принципу, за тем исключением, что мен€ютс€ местами переменные, а также немного видоизмен€етс€ условие. ≈сли ¬ы заметили, то было написанно, что переменна€ Summ, нужна дл€ устранени€ ошибки - да, так и есть. ќшибка заключаетс€ в том, что при последнем цикле первое условии (—м.  од) - отрабатывает, а изменить его никак не удавалось, потому пришлось ввести еще одну переменную.

Ќиже приведен код функции, котора€ заполн€ет массив по спирали. «аполнение происходит только в одном направлении - слева-на-право-сверху-вниз. Ќу кто захочет - сможет переписать еe таким образом, чтобы она стартовала откуда угодно. ”дачи ! 

void FillHelix( int **Mas, int sizeY, int sizeX )
{
  int Summ = sizeX * sizeY;
  int CorrectY = 0;
  int CorrectX = 0;
  int Count = 1;
  while( sizeY > 0 )
  {
    for ( int y = 0; y < 4; y++ )
    {
      for ( int x = 0; x < ( ( sizeX < sizeY ) ? sizeY : sizeX ); x++ )
      {
        if ( y == 0 && x < sizeX - CorrectX && Count <= Summ )
          Mas[y + CorrectY][x + CorrectX] = Count++;
        if ( y == 1 && x < sizeY - CorrectY && x != 0 && Count <= Summ )
          Mas[x + CorrectY][sizeX - 1] = Count++;
        if ( y == 2 && x < sizeX - CorrectX && x != 0 && Count <= Summ )
          Mas[sizeY - 1][sizeX - (x + 1)] = Count++;
        if ( y == 3 && x < sizeY - ( CorrectY + 1 ) && x != 0 && Count <= Summ )
          Mas[sizeY - (x + 1)][CorrectY] = Count++;
      }
    }
    sizeY--;
    sizeX--;
    CorrectY += 1;
    CorrectX += 1;
  }
}